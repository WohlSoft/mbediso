Sort order in UTF-16 =/= sort order in UTF-8 / UTF-32.
- In particular, codepoints U+E000-U+FFFF succeed codepoints UTF+10000 and above in UTF-16.
- This isn't terrible, put these in the buffer as normal, but keep a stack of when the surrogate portion of each character index begins and ends. When an earlier character is modified, swap the surrogate and U+E000 ranges.
- Do not accept unpaired surrogates in any way


- Use AFL++ for fuzzing
  - ./afl-fuzz -i /home/ds-sloth/random/mbediso/build/seeds/ -o /home/ds-sloth/random/mbediso/build/fuzzed -m none -S f2 -d -- /home/ds-sloth/random/mbediso/build/read @@
  - Discovered that "." ".." do not always occur. Made this an error.
  - Discovered that directory entries can be duplicated. Made this an error.
  - Discovered that loop detection isn't working.

- https://en.wikipedia.org/wiki/Red%E2%80%93black_tree

- Possibly use Pearson hashing to accelerate comparisons


Next TODOs:
- Add code to sort a directory
- Add code to lookup in a sorted directory
- Begin work to construct a pathtable of loaded directories (exclude trailing slash so that more string_diffs can be shared)
- Begin work for global stringtable consolidation


Goal for today:
- fix build (done)
- setup the FS directory list (make FS own its directories) (done)
- switch to referring to directories by index (done)
- allow dir_entries to refer to directories (done)
- set up free list of directories (won't do until start work on caching mode)
- set up shared string table (not urgent)
- now, we are already able to start writing an interface!
  - add lookup call (done)
  - begin setting up repo structure



TWO MODES:
- Fully loaded mode
  - Just what it sounds like
  - All directories are sorted, the pathtable is sorted, everything is compacted into a single stringtable owned by the root
  - Pretty easy to force everything (directories, directory entries, pathtable entries naturally, and strings) into single buffers by using a stack-like structure during load
- Caching mode
  - Load directories immediately upon first use
  - Utilize partial matches in the cache (keeping in mind that the closest match may be a child of the requested directory)
  - Will sometimes degrade to direct load -- in this case, DON'T use the ISO pathtable, and DON'T make any assumptions about sort order
  - Not terribly difficult to keep everything in single buffers by using memmove and iterating over cache entries on unload / reallocate.
  - Cache management may require some interesting heuristics

- In both modes, represent data as (roughly) a stack
  - Exception: during fully-loaded mode load phase, the red-black tree of unique strings must be stored elsewhere, and is highly dynamic (I think)
- When loading, first allocate 60 entries per sector, then allocate the strings
  - Then, shrink entries to fit, and hope this leaves enough space for the compacted stringtable
  - In fully-loaded mode, the compacted strings are stored in the unique stringtable -- fairly helpful, though maintaining the unique stringtable may be difficult as well
- When operating in cache mode, the whole stack (past a certain level) will belong to the cached directories.
  - Use a single memmove to move all content past the evicted entry to an earlier address in memory, and update all addresses to point to the earlier address

- Overall memory layout:
  - Static bookkeeping information
    - Includes cache directory structs
  - Directory stack
  - (Fully-loaded mode) string table
    - Includes red-black tree during load time

Refactor everything for memory management EVENTUALLY:
- Load-time RAM:
  - Stack for dir entries
  - Stack for dir strings (compacted dir strings go into a totally different long-term table)
  - Two load buffers (may be used for string processing during the finalize stage)
  - One work buffer


- It should be possible to modify lz4 to include an index allowing seeking blocks (64kb chunks)
  - zero-byte lz4 frame
  - skippable frame incorporating index
  - actual data frame (no dictionary, no block dependence)
  - RAM overhead seems to be around 256kb -- probably okay for Wii if not DSi



Immediate TODO:
(1) get rid of relative dir entries
(2) make FS work correctly even if never loaded
(3) make the I/O pool!
(4) make the shared string table
